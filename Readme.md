Цель: Оценить способность кандидата проектировать бэкенд-сервис с использованием принципов Domain-Driven Design (DDD) и Чистой Архитектуры, демонстрируя четкое разделение на слои Application, Domain и Infrastructure. Кандидат должен использовать наш стек (Bun.js, Elysia.js) и продемонстрировать навыки работы с базой данных и асинхронными операциями.


Описание задачи:


Необходимо разработать бэкенд-сервис для управления задачами. Сервис должен позволять пользователям создавать, просматривать, обновлять и удалять задачи. Особое внимание уделить архитектуре и чистоте кода.


Требования к реализации:
Технологии:
Runtime: Bun.js
Фреймворк: Elysia.js
База данных: PostgreSQL (использовать ORM на выбор кандидата, например, DrizzleORM, Prisma, TypeORM).
Кэширование/Очереди: Redis (для кэширования или для имитации асинхронной обработки, например, отправки уведомлений о просроченных задачах).
Контейнеризация: Docker (для локальной разработки и запуска).
Система контроля версий: Git.
Функциональные требования (API):
Создание задачи:
POST /tasks: Принимает в теле запроса title (строка, обязательное), description (строка, необязательное), dueDate (дата/время, необязательное). Возвращает созданную задачу.
Получение списка задач:
GET /tasks: Возвращает список всех задач. Добавить базовую фильтрацию по статусу (например, ?status=completed).
Получение задачи по ID:
GET /tasks/:id: Возвращает задачу по её уникальному идентификатору.
Обновление задачи:
PUT /tasks/:id: Принимает в теле запроса title, description, dueDate, status (например, "pending", "completed"). Обновляет существующую задачу.
Удаление задачи:
DELETE /tasks/:id: Удаляет задачу по её идентификатору.
Асинхронное уведомление (имитация):
При создании или обновлении задачи с dueDate, если dueDate наступает в ближайшее время (например, в течение 24 часов), необходимо асинхронно (с использованием Redis как имитации очереди) "отправить" уведомление (например, просто записать в лог или отдельный файл) о предстоящем сроке выполнения задачи.
Архитектурные требования (ключевой фокус):
Чистая Архитектура (Clean Architecture) / DDD:
Domain Layer (Доменный слой): Должен содержать бизнес-логику, доменные сущности (Task), Value Objects (если применимо, например, для DueDate), доменные сервисы (если есть сложная логика, не относящаяся к одной сущности), репозитории (интерфейсы). Этот слой не должен зависеть от других слоев.
Application Layer (Слой приложения): Содержит Application Services (например, TaskService), которые координируют действия, используют доменные объекты и репозитории. Обрабатывает use cases. Не должен содержать бизнес-логику.
Infrastructure Layer (Инфраструктурный слой): Реализует интерфейсы репозиториев, определенные в доменном слое. Содержит адаптеры для работы с базой данных (ORM), HTTP-сервер (Elysia.js), Redis и другие внешние зависимости.
Разделение ответственности (SOLID): Продемонстрировать соблюдение принципов SOLID, насколько это возможно в рамках.
Обработка ошибок: Централизованная и корректная обработка ошибок на разных слоях.
Валидация данных: Валидация входящих данных на уровне Application Layer или Domain Layer.
Чистый код: Код должен быть читаемым, хорошо структурированным и следовать общепринятым стандартам.
